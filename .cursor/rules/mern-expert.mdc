---
description: 
globs: 
alwaysApply: true
---
You are an expert in MERN (MongoDB, Express, React, Node.js)

Code Style and Structure
- Write concise, technical TypeScript code with accurate examples.
- Use functional and declarative programming patterns; avoid classes.
- Prefer iteration and modularization over code duplication.
- Use descriptive variable names with auxiliary verbs (e.g., isLoading, hasError).
- Structure files: exported component, subcomponents, helpers, static content, types.

Naming Conventions
- Use lowercase with dashes for directories (e.g., components/auth-wizard).
- Favor named exports for components.

Performance Optimization
- Look for ways to make things faster:
  - Use immutable data structures
  - Use efficient data fetching strategies
  - Optimize network requests
  - Use efficient data structures
  - Use efficient algorithms
  - Use efficient rendering strategies
  - Use efficient state management




## Frontend (React)

* **Use Functional Components & Hooks:** Prefer React function components over class components. Hooks (e.g. `useState`, `useEffect`) make code more concise and manage state and side effects without classes. Always call hooks at the top level of components or custom hooks (no conditional calls) to follow the Rules of Hooks. This approach leads to clearer and more maintainable UI code.

* **State Management:** Handle local component state with built-in hooks like `useState` or `useReducer` for simplicity. For global or shared state, introduce a state management library **only as needed** – small apps might use React Context or a lightweight solution like Zustand, while larger apps benefit from Redux for predictability. Avoid unnecessary global state: lift state up or use context **instead of** Redux if the app is simple, to reduce complexity. Keep state immutable when updating (e.g. use spread operator to create new objects/arrays) so that React can efficiently detect changes.

* **Type Safety with TypeScript:** If using TypeScript, leverage it to catch errors early. Define interfaces or types for component props and state, and let TypeScript infer hook return types when possible. This provides robust compile-time type checking, making the code self-documenting and reducing bugs. Even in JavaScript, consider using PropTypes for runtime type checking of props (or as an additional documentation).

* **Component Organization:** Organize components and files logically for scalability. Group related components together in a feature folder along with their styles and tests. For example, you might have a `components/` directory with subfolders for each component (`Header/`, `Footer/`, etc.), each containing the component file, its CSS/Styled-Components, and its tests. This modular structure makes it easy to locate and maintain code as the project grows.

* **Styling Best Practices:** Use a consistent styling strategy and avoid global CSS leaks. CSS Modules or CSS-in-JS libraries (like styled-components or Emotion) provide scoped styles by generating unique class names, preventing conflicts across components. Choose a method that suits your team, and apply it uniformly (for example, use CSS Modules for most styles and **avoid mixing** multiple approaches in the same project). Steer clear of heavy reliance on global styles; encapsulating styles at the component level (or using a BEM naming convention if using plain CSS) ensures that changes in one area don’t unexpectedly affect others. Also, implement responsive design techniques (media queries, flexible units) so your app looks good on all devices.

* **Performance Optimization:** Pay attention to performance in your React app. Utilize **code splitting** and **lazy loading** for heavy components or routes – load them on demand instead of on initial bundle load. For example, use `React.lazy()` and `Suspense` for dynamic imports of components, which reduces initial load time. Implement memoization for expensive computations or frequently re-rendered child components: use `React.memo` to wrap pure components, and use `useMemo` or `useCallback` hooks to avoid recalculating values or recreating functions unless inputs change. For lists, consider windowing/virtualization (using libraries like `react-window`) so that long lists render only visible items for efficiency. Lastly, avoid unnecessary re-renders by keeping component state minimal and not passing new object literals or functions as props unless needed.

* **Error Handling in UI:** Introduce error boundaries for resilience. An error boundary is a component that catches JavaScript errors anywhere in its child component tree and displays a fallback UI instead of crashing the whole app. Use them around critical sections of your app (e.g. routes or complex components) to ensure one errant component doesn’t break the entire UI. This improves fault tolerance and user experience.

* **Testing & Accessibility:** Treat testing and accessibility as first-class concerns. Write unit and integration tests for your components (using Jest and React Testing Library, for instance) to verify that props, state, and UI output behave as expected. Aim for good coverage on core logic and consider Test-Driven Development (TDD) for complex features to catch bugs early. Also, follow accessibility (a11y) best practices: use semantic HTML elements, provide alt text for images, ensure focus management for interactive elements, and test with screen readers. This not only widens your audience but often leads to cleaner HTML structure in your components.

## Backend (Node.js & Express)

* **Layered Architecture:** Structure the server in clear layers to separate concerns. A common pattern is a three-layer architecture – **web layer** (HTTP interface) with routes, controllers, and middleware; **service layer** for business logic; and **data access layer** for database interactions. In practice, define Express routes that map endpoints to controller functions (each route file handling a resource, e.g. `routes/users.js` for user-related endpoints). Controllers should extract/validate request data and call service methods, then format responses. Business logic lives in services (or managers), completely independent of Express req/res (so it can be reused or tested in isolation). Keeping these layers decoupled makes the code easier to maintain and test, and you could replace or reuse one layer (for example, run service logic from a CLI or cron job) without the web layer.

* **Modular Code Organization:** Organize the project by features or components. For example, group related route, controller, service, and model files under a feature folder (e.g., an `orders/` folder containing `orders.route.js`, `orders.controller.js`, `orders.service.js`, `order.model.js`). This aligns with a component-based structure where each domain (user, order, product, etc.) is self-contained. Another approach is the conventional MVC separation in directories (`routes/`, `controllers/`, `services/`, `models/`). Whichever you choose, be consistent. This modular approach reduces coupling: changes in one module (say, orders) have limited impact on others, and it’s easier for multiple team members to collaborate without stepping on each other’s toes.

* **Middleware Usage:** Leverage Express middleware for cross-cutting concerns and keep your controllers simple. Middleware functions are ideal for tasks like authentication checks, logging, request parsing, rate limiting, etc., which apply to many routes. For example, use a JWT verification middleware to protect certain routes instead of duplicating that logic in every controller. Similarly, have error-handling middleware at the end of your route chain to catch and format errors uniformly. By using middleware, you adhere to DRY principles and separate these concerns from business logic.

* **Error Handling:** Implement a robust error handling strategy. Use `async/await` for asynchronous code and wrap calls in try/catch blocks (or use an Express async middleware helper) to capture errors. Create a centralized error handler middleware that all controllers funnel errors into (by calling `next(err)`), which can log the error and send a proper HTTP response. Distinguish between operational errors (expected issues like invalid input or DB not reachable) and programmer errors (bugs) – handle operational errors gracefully and consider crashing or alerting on programmer errors. Define custom error classes (extending `Error`) for common cases (e.g., `NotFoundError`, `UnauthorizedError`) to add context like HTTP status codes. This way, your error-handling middleware can inspect `err.name` or properties and respond accordingly. Never leak internal error details to clients (sanitize messages), and log full error stacks server-side for debugging.

* **Authentication & Security:** Follow best practices for auth in your Node app. If using sessions, use secure cookies (HttpOnly, Secure, SameSite) and a store (like connect-redis or database) instead of in-memory. If using JWTs for stateless auth, ensure to use strong secrets and safe storage. For example, **use a secure, random secret key at least 32 characters long** for signing JWTs and keep it in an environment variable (never commit secrets). Set JWT expiration times (e.g. short-lived access token + refresh token mechanism) to mitigate risk. Always hash passwords with a proven algorithm (bcrypt, argon2) – never store raw passwords. Use libraries like Passport.js or OAuth providers when possible instead of custom auth to avoid common mistakes. In code, apply authentication/authorization middleware on protected routes to check tokens or sessions, and perform permission checks in your business logic as needed.

* **Async Operations & Performance:** Because Node.js is single-threaded, be mindful of blocking operations. Offload CPU-intensive tasks (e.g. image processing) to worker threads or external services, and use non-blocking async calls for I/O. Use caching (in-memory or Redis) for frequent read operations to reduce database load. For repeated async patterns, consider using utility libraries or patterns (for example, use `Promise.all` for parallel independent calls, or queue tasks to limit concurrency). Additionally, handle unhandled promise rejections and exceptions – for instance, attach handlers to `process.on('unhandledRejection')` and `process.on('uncaughtException')` to log them and shut down/restart gracefully (to avoid the app running in an inconsistent state).

* **Use TypeScript or Strict Coding Standards:** If possible, use TypeScript for the backend. It can catch type errors (like using a response object incorrectly) at compile time and improve IDE assistance. Define types for your data models and for external interfaces (like the shape of `req.body` for specific routes) to reduce runtime errors. If not using TypeScript, enforce strict coding standards via ESLint (e.g., no undefined variables, prefer const, etc.) so that common mistakes are caught early. In either case, thoroughly document functions (via JSDoc or TSdoc) for the next developer's ease.

* **Logging and Monitoring:** Implement logging for debugging and auditing. Use a structured logging library (like Winston or Pino) to log important events, and include contextual information (request IDs, user IDs) in your logs. In Express, a middleware like morgan can log request info; you can extend it or use a custom middleware to log request start/end and errors. Ensure logs (especially errors) are monitored – in production, hook them up to a monitoring service or at least log to files with log rotation. For critical applications, also set up performance monitoring (APM) to catch slow database queries or memory leaks in the Node process.

## Database (MongoDB & Mongoose)

* **Schema Design – Embed vs Reference:** Design your MongoDB schemas based on access patterns. MongoDB **favors embedded documents** for data that is frequently read together, as it avoids joins and offers better performance for those use-cases. For example, embedding an address sub-document inside a user document makes sense if you always fetch them together. However, if data grows large or is accessed independently, use references and separate collections. Mongoose supports references via ObjectId fields with a `ref` option to point to another model. Use this for one-to-many or many-to-many relations where embedding would bloat the document or duplicate data. With the `ref` in place, you can **populate** references to retrieve linked documents easily when needed. In short: embed small, tightly coupled info; reference larger or loosely coupled info.

* **Mongoose Schema Definitions:** Define schemas with clear field types and validators. Every collection should have a schema describing its fields, types, and any constraints (required, unique, etc.) to enforce data integrity in an otherwise schema-less MongoDB. Leverage Mongoose validation features – e.g., use `required: true` for mandatory fields to prevent saving incomplete documents. Set `minlength`, `maxlength` for strings or `min`/`max` for numbers where applicable. Use `enum` for fields that have a fixed set of values (like status or role) to catch invalid values early. These validations run before data is written and will throw a Mongoose `ValidationError` if the rules are violated, ensuring only valid data gets into your database. Also, consider using Mongoose middlewares (pre hooks) for any invariant that needs to be maintained (e.g., hashing a password before save).

* **Indexes for Performance:** Use indexes to optimize query performance. Identify which fields your application queries often or uses for sorting, and create indexes on those fields. For example, if users frequently search by email, ensure the `email` field is indexed. Indexes drastically speed up read operations at the cost of slightly slower writes. Mongoose allows defining indexes in schemas (using the `index: true` option or schema.index() method). You can also enforce uniqueness by setting `unique: true` on a field, which under the hood creates a unique index. This prevents duplicate entries at the database level (for instance, two users with the same email will be rejected). Remember to consider compound indexes (on multiple fields) if queries often specify multiple criteria. **Tip:** Do not over-index every field – indexes consume RAM and slow down writes, so add them judiciously based on query needs. Use MongoDB’s explain plan to verify that your indexes are being used by queries, and drop any indexes that are not helpful.

* **Naming Conventions:** Follow consistent naming conventions for collections and fields. Use **lowercase plural names** for collections (MongoDB will handle this via Mongoose by default, e.g., a model named "Book" corresponds to the "books" collection). Keeping names plural and lowercase avoids confusion (`Users` vs `users`) and aligns with common practice. Field names should be in **camelCase** (e.g., `firstName`, `createdAt`). Avoid using dots (`.`) or dollar signs in field names as they have special meanings in MongoDB. By maintaining consistency in naming, you improve code readability and reduce errors when different developers work on the codebase.

* **Optimize Queries & Use Lean where appropriate:** For heavy read operations, consider using `.lean()` in Mongoose queries to get plain JavaScript objects instead of full Mongoose documents. Lean queries skip the overhead of attaching Mongoose methods to documents, resulting in lower memory usage and faster query execution for read-only data. This is ideal for scenarios where you’re just sending the data in a response and don’t need to use document methods. Additionally, always fetch only what you need – use projection to select fields rather than returning entire documents if you only need a few fields, which reduces bandwidth and memory usage. If you have very large collections, be mindful of queries that scan many documents; ensure proper indexing or consider pagination (with `.limit()` and `.skip()` or ranged queries) to avoid performance issues.

* **Transactions and Atomicity:** MongoDB (in replica set or cluster mode) supports multi-document transactions. If you have updates that span multiple collections or multiple documents that must all succeed or fail together (e.g., an order and an inventory update), use a transaction with `session.startTransaction()` to ensure atomicity. In a MERN context, keep transactions short and handle errors (with abort on failure) properly. Note that transactions can impact performance, so use them only when necessary for maintaining consistency.

* **Backup and Migrations:** As part of best practices, ensure you have a backup strategy for your MongoDB data (regular dumps or cloud backup services) especially for production data. When evolving your schema (adding fields, changing structure), plan migrations for existing data. Mongoose can handle new fields with defaults, but removing or transforming fields might require scripts to migrate old data to the new structure. Consider using tools or writing migration scripts in Node whenever you make significant schema changes.

## Team Collaboration Standards

* **Git Commit Messages:** Use a consistent, descriptive commit message format for all commits. A widely adopted standard is the **Conventional Commits** style, which includes a **type**, an optional scope, and a brief description. For example: `feat(auth): add JWT middleware` or `fix(ui): resolve login button overlap on mobile`. Types like **feat** (new feature), **fix** (bug fix), **docs**, **style**, **refactor**, **test**, **chore** etc., give an immediate idea of the commit’s purpose. This convention makes it easier to read commit history and even automate changelogs or versioning. Ensure commit messages are in the imperative mood (“add feature” not “added feature”) and explain **why** the change was made, not just what changed, especially in the commit body if the title isn't sufficient. Avoid meaningless messages like "updates" or overly large commits that mix concerns.

* **Branch Naming:** Adopt clear branch naming conventions to streamline collaboration. For feature development, bug fixes, hotfixes, etc., use descriptive prefixes and names. For example, you might prefix branches with the type of work: **feature/** for new features, **bugfix/** (or **fix/**) for bug fixes, **hotfix/** for urgent fixes on production, **chore/** for maintenance tasks, and **docs/** for documentation updates. Follow the convention `<category>/<short-description>` – e.g., `feature/user-profile-page` or `bugfix/login-typo`. Use lowercase and hyphenate words for readability. If your team uses issue tracking (JIRA, GitHub issues), include the ticket identifier (e.g., `feature/PROJ-1234-add-payment-api`) for traceability. Consistent branch names make it easy to find, review, and manage branches.

* **Pull Requests & Code Reviews:** All code changes should be submitted via Pull Request (PR) and undergo code review. Set expectations that at least one (preferably two) other developers review the code before merging. In reviews, focus on **code quality, readability, and conformance to standards**: does the code solve the problem correctly and efficiently? Is it well-structured and tested? Are names and styles following the guidelines (no eslint/prettier errors)? Reviewers should follow a checklist – for example: check for readability first, then correctness (including type safety and error handling), then performance and security, and ensure it follows team conventions. They should also run the code or tests if applicable. Feedback must be constructive: ask questions (“What do you think about…?”) and provide suggestions rather than blunt criticism. As a team, cultivate a positive code review culture where the goal is knowledge sharing and improving code, not blame. Authors of PRs should write clear descriptions, link relevant issues, and test their changes before requesting review.

* **Git Workflow:** Define a branching strategy that the team follows (GitFlow, GitHub Flow, trunk-based, etc.) and stick to it. For example, with GitFlow you’d have a `develop` branch for integration, `main` for production, and use feature/bugfix branches that merge into develop, etc. Determine how releases are handled (e.g., release branches or tags). Use protected branches and require PR reviews and passing CI checks before merging to main branches to maintain code quality. Encourage small, frequent merges rather than gigantic merges to reduce merge conflicts and make reviews easier.

* **Documentation Expectations:** Ensure that code is accompanied by appropriate documentation. At a minimum, maintain an up-to-date **README** at the root of the project that explains how to install, run, and build the application, as well as an overview of the project structure. For larger projects, consider a `docs/` folder or a wiki for detailed documentation (architecture decisions, API endpoints, data models, etc.). Every new feature or module should come with either inline code comments or external docs explaining non-obvious implementation details. Adopting templates for certain docs (e.g., an API spec template, or architecture decision records) can ensure consistency and completeness. Also, document **environment variables** and configuration required – for example, provide an `.env.example` file and instructions so new developers know what values to provide. Good documentation practices greatly speed up onboarding and reduce bus factor risks in the team.

* **Conventional Practices:** Embrace additional conventions that improve teamwork. For example, use a consistent **Git commit message** style as mentioned (you can even use commitlint to enforce Conventional Commits). Consider using a tool for **semantic versioning** if the project is a library or has releases, where commit types determine version bumps. In PR descriptions, you might follow a template (with sections like “What does this PR do”, “How to test”, “Screenshot”, “Checklist” etc.). For **issue tracking**, tag and organize issues or user stories in a consistent way. Also, set up regular team routines like stand-ups or sprint planning if using Agile, to coordinate work – while not code-specific, these ensure everyone adheres to the shared goals and practices.

* **Continuous Integration/Code Quality:** Ensure the team uses CI pipelines to run tests, linters, and builds on each PR. Incorporate tools like ESLint, Prettier, and testing frameworks into the pipeline so that code quality issues are caught early and automatically. Many teams use pre-commit hooks (via Husky, for instance) to run linters or tests locally before code even goes up for review. Automated checks free up reviewers to focus on logic and design rather than style issues. Encourage writing **unit tests** for new code and possibly require a certain test coverage level for merges. Ultimately, these standards in collaboration lead to a more maintainable and robust codebase that every team member can confidently contribute to.

## General Coding Practices

* **Linting and Formatting:** Use linters and formatters to maintain a consistent code style across the project. ESLint should be configured for both React and Node portions of the code (include plugins like `eslint-plugin-react` and `@typescript-eslint` if using TS). Adhere to a style guide – many teams adopt Airbnb’s JavaScript/React style guide (available as an ESLint config) for a well-defined set of rules. This catches common issues (unused variables, undeclared variables, improper React hooks usage, etc.) and enforces best practices. Pair ESLint with **Prettier** for code formatting, so things like indentation, quotes, and spacing are automatically consistent. You can use `eslint-config-prettier` to avoid conflicts between ESLint and Prettier rules. With these tools, developers can auto-fix many issues before committing, and the codebase avoids churn from stylistic differences.

* **Project Structure and Clarity:** Maintain a clear project structure. In a MERN stack, typically the front-end (React) and back-end (Node/Express) are separate folders (e.g., `/client` and `/server`), each with its own structure. Within the React app, use a sensible structure (e.g., `src/components/`, `src/pages/`, `src/store/`, `src/hooks/`, etc., segregating presentational components and containers if that pattern is used). Within the Node app, structure source files by their purpose as discussed (routes, controllers, services, models, middleware). Consistently name files and folders – for example, use PascalCase for React component filenames (`UserProfile.jsx`) and kebab-case or camelCase for other files. Having an agreed-upon structure reduces confusion and merge conflicts. Additionally, keep configuration in dedicated places: e.g., have a `config/` directory or files for constants and environment-specific settings. A well-structured project makes it easy for new developers to find things and understand the application flow.

* **Dependency Management:** Manage third-party dependencies carefully. Use a lock file (`package-lock.json` for npm or `yarn.lock` for Yarn) and commit it to version control to lock exact versions and ensure everyone installs the same versions of packages. This guarantees reproducible builds and avoids “works on my machine” issues due to version differences. Be cautious with version ranges in your `package.json`; using exact versions or conservative ranges (`~` for patch updates) can prevent breaking changes, whereas liberal ranges (`^` for minor updates) may auto-upgrade packages which could introduce issues. Regularly **update dependencies** to pull in security fixes and improvements – perhaps schedule time each sprint to review and upgrade outdated packages. Use automated tools (npm outdated, `npm audit`, or services like Dependabot) to stay informed about vulnerabilities. However, test your application after upgrades, and consider major version bumps carefully (read release notes for breaking changes). Remove dependencies that aren’t used to keep the project lean.

* **Environment Variables & Config:** Handle configuration via environment variables or config files, not hardcoded constants. All secrets and environment-specific config (database URLs, API keys, etc.) should reside in environment variables for security and flexibility. For local development, use a `.env` file (which is listed in `.gitignore`) to store these variables, and load it using the `dotenv` package. It’s common to have multiple .env files like `.env.development`, `.env.test`, `.env.production` with appropriate values, or a single .env with a variable like `NODE_ENV` to switch configs. The application should read from `process.env` (or a config module that wraps it) so that changing the environment doesn’t require code changes. **Never commit .env files or secrets** to the repo – treat them as sensitive. Also, document what env vars are needed. For better structure, consider using a config library (like `rc` or even a simple custom `config.js`) that centralizes all configuration, pulling from env vars and providing defaults. This makes it easier to access config throughout the app and to see all config in one place. By externalizing configuration, you improve security and deployability of the app (12-factor app principles).

* **Quality Assurance:** Maintain high code quality by writing tests and using type-checking. In addition to unit tests, consider integration tests (for API endpoints using supertest, for example) to ensure all pieces work together. If using TypeScript, treat compiler warnings as errors and strive for strict type checking (enable `strict` mode in tsconfig) for maximum benefit. Use commit hooks or CI checks to run your test suite and linters on each commit/PR. Enforce coding standards like avoiding functions that are too large or deeply nested – if a function or module grows too complex, refactor into smaller units (single-responsibility principle). Keep functions pure where possible (especially in React selectors or Redux reducers) to make testing easier. Regularly pay off tech debt; don’t let “temporary” hacks accumulate without tickets to address them.

* **Performance and Monitoring:** Write code with performance in mind. This means being mindful of algorithmic complexity (avoid deeply nested loops on large data, etc.), but also using tools to monitor and profile. For Node, use profilers or APM tools to catch slow database queries or memory leaks. For React, use the React DevTools Profiler to identify slow components. Optimize only where needed – e.g., if an endpoint is slow, profile it to find the bottleneck (DB query, data processing, etc.) and address it (add an index, caching, optimize logic). Also, guard against memory leaks by cleaning up timers or intervals, and in React effect hooks, always clean up subscriptions or timers on unmount. Having a performance-conscious mindset will save debugging time down the road.

* **Security Best Practices:** Keep security in focus as a general practice. Sanitize and validate all external input (use something like `express-validator` or Joi for request data validation in Express). Use parameterized queries or ODM methods properly to avoid injection attacks for MongoDB. Implement headers for security (helmet middleware in Express to set XSS/CSRF headers, etc.). In React, avoid interpolating untrusted data in the DOM (use React’s state mechanisms which auto-escape, or if using `dangerouslySetInnerHTML`, ensure the content is sanitized). Store sensitive data in secure ways (HttpOnly cookies for tokens, etc., as mentioned). Regularly update dependencies to get security fixes (as noted in dependency management). Possibly run security scanners (like npm audit, or tools like Snyk) to catch known vulnerabilities. Ensuring these practices are followed will harden the application against common threats.

By following these best practices in frontend, backend, database management, and team processes, a MERN stack project will be more maintainable, scalable, and collaborative. They establish a strong foundation so the team can focus on feature development with confidence that the codebase remains clean, performant, and secure.;

